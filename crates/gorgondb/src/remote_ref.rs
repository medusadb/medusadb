use std::{fmt::Display, str::FromStr};

use byteorder::ReadBytesExt;
use bytes::Bytes;
use serde_with::{DeserializeFromStr, SerializeDisplay};
use thiserror::Error;

use crate::{buf_utils, HashAlgorithm};

/// An error type for [``RemoteRefs``](``RemoteRef``).
#[derive(Debug, Error)]
pub enum Error {
    /// The remote-reference is invalid.
    #[error("invalid remote-reference: {0}")]
    InvalidRemoteRef(String),
}

/// A remote-reference to a blob of data.
///
/// In most case, you should not need to deal with this type, but rather with [`crate::Cairn`].
///
/// # Handling remote-references
///
/// Remote references are designed to be printable and - as such - parseable. To remain space
/// efficient, they are displayed using [`base85`](https://datatracker.ietf.org/doc/html/rfc1924).
#[derive(Debug, Clone, PartialEq, Eq, Hash, DeserializeFromStr, SerializeDisplay)]
pub struct RemoteRef {
    pub(crate) ref_size: u64,
    pub(crate) hash_algorithm: HashAlgorithm,
    pub(crate) raw: Bytes,
}

impl RemoteRef {
    /// Compute a remote reference for a **non-empty** slice of data.
    ///
    /// The resulting `RemoteRef` should only ever be used to refer to a strictly identical blob of
    /// data.
    ///
    /// `info_bits` are 4 bits of unspecified meaning to embed in the resulting binary value.
    ///
    /// # Panics
    ///
    /// If the specified slice is empty, the call panics.
    /// If the info bits exceeds 15, the call panics.
    pub fn for_slice(buf: &[u8], info_bits: u8) -> Self {
        assert!(!buf.is_empty(), "slice cannot be empty");

        let ref_size = buf
            .len()
            .try_into()
            .expect("slice's length should fit within an u64");
        let hash_algorithm = HashAlgorithm::Blake3;

        let mut w = Vec::with_capacity(
            1 + buf_utils::buffer_size_len(ref_size) as usize + 1 + hash_algorithm.size(),
        );

        buf_utils::write_buffer_size(&mut w, ref_size, info_bits)
            .expect("raw buffer should be big enough");
        w.push(hash_algorithm.into());
        hash_algorithm
            .hash_to(&mut w, buf)
            .expect("raw buffer should be big enough");

        Self {
            ref_size,
            hash_algorithm,
            raw: w.into(),
        }
    }

    /// Get the size of the referenced buffer.
    pub fn ref_size(&self) -> u64 {
        self.ref_size
    }

    /// Get the hash algorithm used to hash the remote reference.
    pub fn hash_algorithm(&self) -> HashAlgorithm {
        self.hash_algorithm
    }

    /// Get the hash associated to the remote reference.
    pub fn hash(&self) -> &[u8] {
        &self.raw[1 + buf_utils::buffer_size_len(self.ref_size) as usize + 1..]
    }
}

impl Display for RemoteRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&base85::encode(self.as_ref()))
    }
}

impl FromStr for RemoteRef {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let raw: Bytes = base85::decode(s)
            .map_err(|err| {
                Error::InvalidRemoteRef(format!("failed to parse base85 string: {err}"))
            })?
            .into();

        raw.try_into()
    }
}

impl TryFrom<Bytes> for RemoteRef {
    type Error = Error;

    fn try_from(raw: Bytes) -> Result<Self, Self::Error> {
        let mut r = std::io::Cursor::new(&raw);
        match buf_utils::read_buffer_size(&mut r).map_err(|err| {
            Error::InvalidRemoteRef(format!("failed to read reference size: {err}"))
        })? {
            (Some(ref_size), _info_bits) => {
                let hash_algorithm = r
                    .read_u8()
                    .map_err(|err| {
                        Error::InvalidRemoteRef(format!("failed to read algorithm: {err}"))
                    })?
                    .try_into()
                    .map_err(|err| {
                        Error::InvalidRemoteRef(format!("failed to parse algorithm: {err}"))
                    })?;

                Ok(Self {
                    ref_size,
                    hash_algorithm,
                    raw,
                })
            }
            (None, _) => Err(Error::InvalidRemoteRef("missing buffer size".to_owned())),
        }
    }
}

impl From<RemoteRef> for Bytes {
    fn from(value: RemoteRef) -> Self {
        value.raw
    }
}

impl TryFrom<&'_ [u8]> for RemoteRef {
    type Error = Error;

    fn try_from(value: &'_ [u8]) -> Result<Self, Self::Error> {
        Bytes::copy_from_slice(value).try_into()
    }
}

impl AsRef<[u8]> for RemoteRef {
    fn as_ref(&self) -> &[u8] {
        &self.raw
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use serde_json::json;

    #[test]
    fn test_remote_ref() {
        let expected = "0RaI>{Bj?=!E)e|U!r>PXC2}tx{`4;fGL=<3KeLfh-E7";
        let remote_ref: RemoteRef = expected.parse().unwrap();
        assert_eq!(remote_ref.to_string(), expected);

        let remote_ref: RemoteRef = serde_json::from_value(json!(expected)).unwrap();
        assert_eq!(serde_json::to_value(remote_ref).unwrap(), json!(expected));
    }

    #[test]
    fn test_remote_ref_for_slice() {
        let remote_ref = RemoteRef::for_slice(&[0x01], 0);

        assert_eq!(
            remote_ref.as_ref(),
            &[
                0x01, 0x01, 0x01, 0x48, 0xfc, 0x72, 0x1f, 0xbb, 0xc1, 0x72, 0xe0, 0x92, 0x5f, 0xa2,
                0x7a, 0xf1, 0x67, 0x1d, 0xe2, 0x25, 0xba, 0x92, 0x71, 0x34, 0x80, 0x29, 0x98, 0xb1,
                0x0a, 0x15, 0x68, 0xa1, 0x88, 0x65, 0x2b,
            ]
        );

        assert_eq!(remote_ref.ref_size(), 1);
        assert_eq!(remote_ref.hash_algorithm(), HashAlgorithm::Blake3);
        assert_eq!(
            remote_ref.hash(),
            &[
                0x48, 0xfc, 0x72, 0x1f, 0xbb, 0xc1, 0x72, 0xe0, 0x92, 0x5f, 0xa2, 0x7a, 0xf1, 0x67,
                0x1d, 0xe2, 0x25, 0xba, 0x92, 0x71, 0x34, 0x80, 0x29, 0x98, 0xb1, 0x0a, 0x15, 0x68,
                0xa1, 0x88, 0x65, 0x2b,
            ]
        );

        let other = remote_ref.as_ref().try_into().unwrap();
        assert_eq!(remote_ref, other);

        let remote_ref = RemoteRef::for_slice(
            &[
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04,
            ],
            0,
        );

        assert_eq!(
            remote_ref.as_ref(),
            &[
                0x01, 0x20, 0x01, 0x9c, 0x4d, 0x78, 0xc2, 0xd6, 0x5a, 0x8e, 0x17, 0x2b, 0x68, 0x4e,
                0xec, 0xac, 0x47, 0x05, 0x24, 0x15, 0x57, 0xe8, 0x60, 0xe9, 0xa0, 0x41, 0x56, 0x37,
                0x36, 0xfc, 0x16, 0x02, 0xac, 0x1f, 0x08,
            ]
        );

        assert_eq!(remote_ref.ref_size(), 32);
        assert_eq!(remote_ref.hash_algorithm(), HashAlgorithm::Blake3);
        assert_eq!(
            remote_ref.hash(),
            &[
                0x9c, 0x4d, 0x78, 0xc2, 0xd6, 0x5a, 0x8e, 0x17, 0x2b, 0x68, 0x4e, 0xec, 0xac, 0x47,
                0x05, 0x24, 0x15, 0x57, 0xe8, 0x60, 0xe9, 0xa0, 0x41, 0x56, 0x37, 0x36, 0xfc, 0x16,
                0x02, 0xac, 0x1f, 0x08,
            ]
        );

        let other = remote_ref.as_ref().try_into().unwrap();
        assert_eq!(remote_ref, other);

        let remote_ref = RemoteRef::for_slice(
            &[
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02,
                0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
            ],
            0,
        );

        assert_eq!(
            remote_ref.as_ref(),
            &[
                0x02, 0x02, 0x00, 0x01, 0x44, 0x80, 0x4d, 0x04, 0x99, 0xdb, 0x3a, 0x70, 0x27, 0x3a,
                0xed, 0x86, 0xec, 0xdc, 0xa6, 0x92, 0x57, 0xa1, 0xe6, 0x5b, 0x8e, 0xd0, 0xb8, 0x26,
                0x50, 0xbd, 0x5b, 0xf8, 0x6a, 0x2a, 0x8d, 0x39,
            ]
        );

        assert_eq!(remote_ref.ref_size(), 512);
        assert_eq!(remote_ref.hash_algorithm(), HashAlgorithm::Blake3);
        assert_eq!(
            remote_ref.hash(),
            &[
                0x44, 0x80, 0x4d, 0x04, 0x99, 0xdb, 0x3a, 0x70, 0x27, 0x3a, 0xed, 0x86, 0xec, 0xdc,
                0xa6, 0x92, 0x57, 0xa1, 0xe6, 0x5b, 0x8e, 0xd0, 0xb8, 0x26, 0x50, 0xbd, 0x5b, 0xf8,
                0x6a, 0x2a, 0x8d, 0x39,
            ]
        );

        let other = remote_ref.as_ref().try_into().unwrap();
        assert_eq!(remote_ref, other);
    }
}
